<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-programming-from-the-ground-study" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/31/programming-from-the-ground-study/" class="article-date">
  <time datetime="2016-10-31T06:33:14.000Z" itemprop="datePublished">2016-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/31/programming-from-the-ground-study/">programming_from_the_ground_study</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Chapter 1. Introduction</p>
<p>Three kinds of language:</p>
<ol>
<li>Machine Language</li>
<li>Assembly Language</li>
<li>High-Level Language : allow you to describe the program in a more natural language.<br>A single command in a high-level language usually is equivalent to several commands in<br>an sssembly language.</li>
</ol>
<p>Hopefully by learning assembly language, your understanding of how programming and computers work will put you a step ahead.</p>
<p>#Chapter 2 Computer Architecture<br>Modern computer architecture is based off of an architecture called the Von Neumann architecture.</p>
<p>The Von Neumann architecture divides the computer up into 2 main parts :</p>
<ol>
<li>CPU : Central Processing Unit</li>
<li>The Memory.</li>
</ol>
<p>In fact, in a computer, there is no difference between a program and a program’s data except how it is used by the computer. They are both sored an accessed the same way.</p>
<p>The CPU reads in instructions from memory one at a time and executes them. This is knows as the fetch-execute cycle.The CPU contains the following elements to accomplish this:</p>
<ul>
<li>Program Counter : holds the memory address of the next instruction to be executed.</li>
<li>Instruction Decoder : figures out what the instruction means.</li>
<li>Data Bus : fetch the memory locations to be used in the calculation. is the connection between the CPU a<br>nd memory.</li>
<li>General-purpose registers : Computers have very few general-purpose registers. Most informaction is       stored in main memory, brought in to the registers for processing, and then put back into memroy when the processing is completed. <strong>Special-purpose registers</strong> are registers which have very specifiy purposes.</li>
<li>Arithmetic and logic unit : when the CPU have retrieved all of the data it needs, it passes on the data and the decoded instructions to the arithmetic and logic unit for further processing.</li>
</ul>
<p>Computer instructions usually consist of both the actual instruction and the list of memory locations that are used to carry it out.</p>
<p>Although the basic operation is still the same, it’s complicated by the use of :</p>
<ul>
<li>cache hierarchies</li>
<li>superscalar processors</li>
<li>pipelining</li>
<li>branch prediction</li>
<li>out-of-order execution</li>
<li>microcode translation</li>
<li>coprocessors</li>
</ul>
<p>Computer memory is a numbered sequence of fixed-size storage locations.The number attached to each storage locations is called it’s <em>address</em>. The size of single storage locations is called a <em>byte</em>.</p>
<p>When displaying to the screen, the computer uses ASCII Code Tables to translate the numbers you are sendingit into letters to display on the screen, wich each number translating to exactly one letter or numeral. “HELLO” -&gt; 72, 69, 76, 76, 76, 79</p>
<p>Simply use a combination of bytes to represent larger numbers.</p>
<p><strong>Registers</strong> are what the computer uses for computation. Registers keep the contents of numbers that you are currently manipulating.</p>
<p>The size of a typical register is called a computers’s <strong>word size</strong>.</p>
<p>Addresses are 1 word long, and therefore also fit into a register.</p>
<p>In fact, the computer can’t tell the difference between a value that is an address, a valud that is a number, a value that is an ASCII code, or a value that you have deciede to use for another purpose.</p>
<p>Addresses which are stored in memory are also called pointers, because instead of having a regular value in them, they point you to a different location in memroy.</p>
<p>The only way the computer knows that a memory location is an instructions is that a speical-purpose register called the instruction pointer points to them at one point or another. If the instruction pointer points to a memory word, it’s loaded as an instruction.</p>
<p>Processors have a number of different ways of accessing data, known as <em>addressing modes</em>.</p>
<ul>
<li>immediate mode : the data to accesss is embedded in the instruction itself.</li>
<li>register addressing mode : the instruction contains a register to access, rather than a memory location.</li>
<li>direct addressing mode : the instruction contains the memory address to access.</li>
<li>indexed addressing mode : the instruction contains a memory address to access, and also specified an index register to offset that address.</li>
<li>indirect addressing mode : the instruction contains a register that contains a pointer to where the data should be accessed.</li>
<li>base pointer addressing mode : similar to indirect addressing, but you alos include a number called the offset to add to the register’s value before using it for lookup.</li>
</ul>
<h1 id="Chapter-3-Your-First-Programs"><a href="#Chapter-3-Your-First-Programs" class="headerlink" title="Chapter 3. Your First Programs"></a>Chapter 3. Your First Programs</h1><p>Please tinker around with the programms as much as you can. Even if your tinkering does not work, every failure will help you learn.</p>
<p>In order to transform a source code into a program that a computer can run, we need to assemble and link it.</p>
<p>Assembling is the process that transforms what you typed into instructions for the machine.Assembling transforms the huma-readable file into a machine-readable one.</p>
<p>An object file is code that is in the machine’s language, but has not been completely put together.</p>
<p>The linker is the program that is responsbile for putting the object files together and adding information to it so that the kernel knows how to load and run it.</p>
<p>You must always re-assemble and re-link programs after you modify the source code for the changes to occur in the program. </p>
<p>Unix executables usually have no extension.</p>
<p>Anything starting with a period isn’t directly translated into a machine instruction. Instead, it’s an instruction to the assembler itself. These are called assembler directives or pseduo-operations because they are handled by the assembler and are not actually run by the computer.</p>
<p>.section .data<br>The .section command breaks your program up into sections.This command starts the data section, where you list any memory storage you will need for data.</p>
<p>.section .text<br>which starts the text section. The text section of a program is where the program instructions live.</p>
<p>.global _start</p>
<p>This instructs the assembler than _start is important to remember._start is a symbol, which means that it is going to be replaced by something else either during assembly or linking. Symbols are generally used to mark locations of programs or data, so you can refer to them by name instead of by their location number.</p>
<p>Symbols are used so that the assember and linker can take care of keeping track of addresses, and you can concentrate on writing your program.</p>
<p>.global means that the assembler shouldn’t discard this symbol after assembly, because the linker will need it. _start is a special symbol that always needs to be marked with .globl because it marks the location of the start of program. <em>Without marking this location in this way, when the computer load your program it won’t know where to begin running your program.</em></p>
<p>_start:<br>defines the valule of the _start lable. A label is s symbol followed by a colon. Labels defind a symbol’s value. When the assembleer is assembling the program, it has to assign each data value and instruction an address.</p>
<p>movl $1, %eax<br>In assembly language, many instructions have operands. movl has two operands - the source and the destination. Operands can be numbers, memory location references, or registers.</p>
<p>On most instructions which have two operands, the first one is the source operand and the second one is the destination. Note that in these cases, the source opreand is not modified at all.</p>
<p>On x86 processors, there are several general-purpose registers:</p>
<ul>
<li>%eax</li>
<li>%ebx</li>
<li>%ecx</li>
<li>%edx</li>
<li>%edi</li>
<li>%essi </li>
</ul>
<p>In addtions to these general-purpose registers, there are also several special-purpose registers, including:</p>
<ul>
<li>%ebp</li>
<li>%esp</li>
<li>%eip</li>
<li>%eflags</li>
</ul>
<p>%rax is 64-bit version of %eax.</p>
<p>The dollar-sign in front of the one indicates that we want to use immediate mode addressing. Without the dollar-sign it would do direct addressing, loading whatever number is at address 1.</p>
<p>The number 1 is t he number of the exit system call.</p>
<p>Many operations such as calling other programs, dealing with files, and exiting have to be handled by the operating system through system calls.</p>
<p>The operationg system, however, usually need more information than just which call to make. For example, when dealing with files, the operating system needs to know which fild you are dealing with, what data you want to write, and other details. The extra details, called parameters are stored in other registers.</p>
<p>Linux simply requires that certain registers be loaded with certain parameter values before making a system call.</p>
<p>%eax is always required to be loaded with the system call number.</p>
<p>In the exit system call, %ebx is required to be loaded with the exit status.</p>
<p>int $0x80<br>The int stands for interrupt. The 0x80 is the interrupt number to use. An interrupt interrupts the normal program flow, and transfers control from our program to Linux so that it will do system call.</p>
<p>Actually, the interrupt transfers control to whoever set up an interrupt handler for the interrupt number. In the case of Linux, all of them are set to be handled by the Linux kernel.</p>
<p>If we didn’t signal the interrupt, then no system call would have been performed.</p>
<p>recap: 重新分类，重新归纳</p>
<p>Operating System features are accessed through system calls. There are invoked by settign up the registers in a special way and issuing the instruction int $0x80. Linux knows which system call we want to access by what we stored in the %eax register. Each system call has other requirements as to what need to be stored in the other registers. System call number 1 is the exit system call, which requires the status code to be placed in %ebx.</p>
<p>To assembly the program type in the command:<br>as exit.s -o exit.o</p>
<p>The link the file, enter the command:<br>ld exit.o -o exit</p>
<p>Remember that any time you change the source file, you have to re-assemble and re-link your program.</p>
<p>leave out : 遗漏，不考虑</p>
<p>indexed addressing mode instrustion :<br>movl BEGINNINGADDRESS(, %INDEXREGISTER, WORDSIZE)</p>
<p>The compare instruction also affects a register not mentioned here, the %eflags register. The is also known as the status register. Just be aware that the result of the comparison is stored in the status register.</p>
<p>Jump statements:</p>
<ol>
<li>je : Jump if the values were equal</li>
<li>jg : Jump if the second value was greater than the first value</li>
<li>jge : Jump if the second value was greater than or equal to the first value</li>
<li>jl : Jump if the second value was less than the first value.</li>
<li>jle : Jump if the second value was less than or equal to the first value.</li>
<li>jmp : Jump no matter what. </li>
</ol>
<p>The general form or memory address references is this:</p>
<p>ADDRESS_O_OFFSET(%BASE_OR_OFFSET, %INDEX, MULTIPLIER)</p>
<p>direct addressing mode:</p>
<p>movl ADDRESS, %eax</p>
<p>indexed addressing mode:</p>
<p>movl string_start(, %ecx, 1), %eax</p>
<p>indirect addressing mode:</p>
<p>movl (%eax), %ebx</p>
<p>base pointer addressing mode:</p>
<p>movl 4(%eax), %ebx</p>
<p>immediate mode: it’s used to load direct values into registers or memory locations.</p>
<p>movl $12, %eax</p>
<p>register addressing mode: simply moves data in or out of a register.</p>
<p>If you only wanted to work with two bytes at a time, you could just use %ax. %ax is the least-significant half of the %eax register, and is useful when dealing with two-byte quantities. %ax is further divided up into %al and %ah. %al is the least-significant byte of %ax, and %ah is the most significant byte.</p>
<h1 id="Chapter-4-All-about-Functions"><a href="#Chapter-4-All-about-Functions" class="headerlink" title="Chapter 4. All about Functions"></a>Chapter 4. All about Functions</h1><p>To assist programmers in workding together in groups, it’s necessary to break programs apart into seperate pieces, which communicate with each other through well-defined interfaces.</p>
<p>However, ultimately there are thing that you cannot write functions for which must be provided by the system. Those are called primitive funtions(or just primitives) - they are the basics which everything else is built off.</p>
<p>In assembly language, the primitives are usually the same thing as the system calls, even though system calls aren’t true functions.</p>
<p>the call instruction handles passing the return address for you, and ret handles using that address to return back to where you called the function from.</p>
<p>Each computer program that runs uses a region of memory called the stack to eable functions to work properly.</p>
<p>The computer’s stack lives at the very top addresses of memory.</p>
<p>In memory the stack starts at the top of memory and grows downward due to architectural considerations. Therefore, when we refer to the “top of stack” remember it’s at the bottom of the stack’s memory.</p>
<p>How do we know where the current top of stack is ? The stack register, <strong>%esp, always contains a pointer to the current top of the stack</strong>, wherever it is.</p>
<p>Every time we push something onto the stack with pushl, %esp get subtracted by 4 so that it points to the new top of stack(remember, each word is four bytes long, and the stack grows downward).</p>
<p>Before executing a function, a program pushes all of the paramters for the function onto the stack in the reverse order that they are documented.</p>
<p>The call instruction does two things : First it pushes the address of the next instruction, which is the return address, onto the stack. <strong>Then it modifies the instruction pointer (%eip) to point to the start of the function</strong>.</p>
<p>base pointer register : %ebp. The base pointer is a special register used for accessing function parameters and local variables.</p>
<p>Copying the stack pointer into the base pointer at the beginning of a function allows you to always know where your parameters are, even while you may be pushing things on and off the stack.</p>
<p>%ebp will always be where the stack pointer was at the beginning of the function.</p>
<p>Stack frame : it consists of all of the stack variables used within a function, including paramters, local variables, and the return address.</p>
<p>clobber : 痛打, 击倒, 拉垮</p>
<p>The only difference between the global and static variables is that static variables are only used by one function, while global variables are used by many functions.</p>
<p>When the function done executing , it stores it’s return value in %eax.</p>
<p>Before a function returns control to the code that called it, it must restore the previous stack frame.</p>
<p>Before return , we have to reset the stack pointer %esp, and the base pointer %ebp to what they were when the function began.</p>
<p>Therefore to return from a function you have to do the following :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movl %ebp, %esp</div><div class="line">popl %ebp</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>At this point, you should consider all local variable to be disposed of.</p>
<p>C language convention : also known as ABI, or Application Binary Interface.</p>
<p>The difference between call and jmp is that call also pushes the return address onto the stack so that the function can return, while the jmp does not.</p>
<p>stretch : 伸展，Stretch your brain.</p>
<p>The base case is the point where recursion will stop. Without a base case, the function would go on forever calling itself until it eventually ran out of stack space. </p>
<p>You should always clean up your stack parameters after a function call returns.</p>
<p>pushl %ebp<br>movl %esp, %ebp<br>This create the stack frame for this function. These two lines will be the way you should start every function.</p>
<h1 id="Chapter-5-Dealing-with-Files"><a href="#Chapter-5-Dealing-with-Files" class="headerlink" title="Chapter 5. Dealing with Files"></a>Chapter 5. Dealing with Files</h1><p>Data which is stored in files is called persistent data.</p>
<p>Open file is handled with the open system call:</p>
<ul>
<li>%eax hold the system call number : 5</li>
<li>%ebx : the address of the first character of the filename</li>
<li>%ecx : the read/write intentions, 0 as the read from, 03101 write to(must include the leading zero)</li>
<li>%edx : the permission</li>
</ul>
<p>Linux will then return to you a file descriptor in %eax. Remember, this is a number than you can use to refer to this file throughout your program.</p>
<p>Error codes can be distinguished because they are always negative numbers.</p>
<p>The write systeme call will give back the number of bytes written in %eax or an error code.</p>
<p>When you are through with your files, you can then tell Linux to close them. Afterwards, your file descriptor is no longer valide. close , system call 6.</p>
<p>A buffer is a continuous block of bytes used fo bulk data transfer.</p>
<p>.bss, this section is like the data section, except that it doesn’t take up space in the executable. This section can reserve storage, but it can’t initialize it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.section .bss</div><div class="line">.lcomm my_buffer, 500</div><div class="line"></div><div class="line">movl $my_buffer, %ecx</div><div class="line">movl 500, %edx</div><div class="line">movl 3, %eax</div><div class="line">int $0x80</div></pre></td></tr></table></figure>
<p>Without the dollar sign, my_buffer is treated as a memory location, and is accessed in direct addressing mode. The dollar sign switcheds it to immediate mode addressing, which actually loads the number represented by my_buffer (which is the address of my_buffer) itself into %ecx.</p>
<p>In Linux, almost everyhing is a “file”.</p>
<p>Linxu programs usually have at lease three open file descriptors when they begin.</p>
<ul>
<li>STDIN : Standard input. it’s a read-only file, and usually represents your keyboard. This is always file descriptor 0.</li>
<li>STDOUT: Standard output. it’s write-onnly file, and usually represents your screen display. This is always file descriptor 1.</li>
<li>STDERR: Standard error. it’s write-only file, and usually represents your screen display. This is always file descriptor 2.</li>
</ul>
<p>Communication between processed is usually done through special files called pipes.</p>
<p>Notice that many of the files you write to aren’t files at all. Some of these files have different methods of opening and creating them than regular files(i.e. - they don’t use the open system call), but they can all be read form and written to using the standard read and write system calls.</p>
<p>Coding is complex, but there are a lot of things we can do like this to make it easier.</p>
<p>In assembly language, we declare constants with the .equ directive.</p>
<p>Subtracting an upper-case letter from the same lower-case letter gives us how much we nend to add to a lower-case letter ot make it upper case.</p>
<p>Using symbols for these numbers instead of the numbers themselves makes it easier to see what data is being used and moved.</p>
<p>Guarding againt potential user and programming erros is a important task of a programmer.</p>
<p>Before rading and writing the files we must open them.</p>
<p>Fortunately, command-line parameters are already stored by Linux in an easy-to-acces location, and are already null-terminated. When a Linux program begins, all pointers to command-line arguments are stored on the stack.</p>
<p>The number of arguments is stored at 8(%esp), the name of the program is stored at 12(%esp), and the arguments are stored from 16(%esp) on.</p>
<p>In normal programs, every system call should normally be checked for success or failture. In failture cases, %eax will hold an error code instead of a return value.</p>
<p>end-of-file : the number 0</p>
<h1 id="Chapter-6-Reading-and-Writing-Simple-Records"><a href="#Chapter-6-Reading-and-Writing-Simple-Records" class="headerlink" title="Chapter 6. Reading and Writing Simple Records"></a>Chapter 6. Reading and Writing Simple Records</h1><p>.include “linux.s”<br>These statements cause the given files to basically be pasted right there in code. You don’t need to do this with functions, because the linker can take care of combining functions export with .globl.</p>
<p>Assembler directive .rept. This direcive repeats the content of the file between .rept and .endr directives the number of times specified after .rept. </p>
<h1 id="Chapter-7-Developing-Robust-Programs"><a href="#Chapter-7-Developing-Robust-Programs" class="headerlink" title="Chapter 7. Developing Robust Programs"></a>Chapter 7. Developing Robust Programs</h1><p>Robust programs are able to handle error conditions gracefully. Building robust programs is essential to the practice of programming. Writing robust programs takes discipline and work - it usally entails finding every possible problem that can occur, and coming up with an action plan for your program to take.</p>
<p>Remember that every error message that pops up on your screen had to be prgrammed in by someone.</p>
<p>Most important is testing corner cases or edge cases. Corner cases are the inputs that are most likely to casue problems or behave unexpectedly.</p>
<p>contingency :  偶然性, 可能性, 意外事故</p>
<p>Truly robust software has a uniqe erro code for every possible contingency.</p>
<p>Error codes should also be accompanied by descriptive error messages.</p>
<p>A troubleshooting guide, not the program itself, is an appropriate place to list possible reasons and cources for action for each error message.</p>
<p>After every system call, function call, or instruction which can have erroneous results you should add error checking and handling code.</p>
<p>In programming, these shared code files are referred to as shared libraries, shared objects, dynamic-link libraries, DLLs, or .so files.</p>
<p>In previous chapters, the linker would resolve all of the names to physical memory addresses, and the names wolud be thrown away. When using dynamic linking, the name itself resides within the exectuable, and is resolvde by the dynamic linker when it’s run. When the program is run by the user, the dynamic linker loads the shared libraries listed in our link statement, and then finds all of the functions and variable names that were named by our program but not found at link time, and matcheds them up with correspoing entries in the shared libraries it loads. It then replaces all of the names with the addresses which they are loaded at. This sounds time-consuming. It is to a small degress, but it only happens once - at the program startup time.</p>
<p>When you use shared libraries, your program is then dynamically-linked, which means that not all of the code needed to run the program is actually contained within the program file itself, but in external libraries.</p>
<p>/lib/ld-linux.so.2 : dynamic linker</p>
<p>standard places : listed in /etc/ld.so.conf and in the contents of the LD_LIBRARY_PATH environment variable.</p>
<p>Run the ldd program on various programs that are on your Linux distribution, and see what libraries they rely on.</p>
<p>null character : \0</p>
<p>thorough : 十分的，彻底的</p>
<p>ld -shared write-record.o read-record.o -o librecord.so<br>This links both of these files together into a shared library called librecord.so</p>
<p>LD_PRELOAD</p>
<h1 id="Chapter-9-Intermediate-Memory-Topics"><a href="#Chapter-9-Intermediate-Memory-Topics" class="headerlink" title="Chapter 9. Intermediate Memory Topics"></a>Chapter 9. Intermediate Memory Topics</h1><p>Each instruction is a different length. Most instruations take up one or two storage locations for the instruction itself, and then storage locations for the instrution’s arguments.</p>
<p>Word:<br>This is the size of normal register. On x86 processors, a word is four bytes long. Most computer operations handle a word at a time.</p>
<p>An address is a number that refers to a byte in memeory. </p>
<p>Every piece of data on the computer not in a register has an address.</p>
<p>Normally, we don’t ever type the nummeric address of anything, but we let the assembler do it for us. When we use labels in code, the symbol used in the label will be equivalent to address it is labelling.</p>
<p>A pointer is a register or memory word whose value is an address.</p>
<p>When your program is loaded into memory, each .section is loaded into its own region of memory. All of the code and data declared in each section is brought together, even if they were seperated in your source code.</p>
<p>The actual instructions(the .text section) are loaded at the address 0x08048000. The .data section is loaded immediately after that, followed by the .bss section.</p>
<p>The last byte than can be addressed on Linus is location 0xbffffff. Linux start the stack here and grows it downward toward the other sections.</p>
<p>Your program’s data region starts at the bottom of memory and goes up. The stack start at the top of memory, and moves downward with each push.</p>
<p>The last accessible memory address to your program is called the system break (also called the current break or just the break).</p>
<p>step on :踩上，踏上</p>
<p>As a program writer, you only access virtual memory.</p>
<p>Physical memory refers to the actual RAM chips inside your computer and what they contain.</p>
<p>Virtual memory is the way your program thinks about memory.</p>
<p>The process of assigning virtual addresses to physical addresses is called mapping.</p>
<p>Virtual memory can be mapped to more than just physical memory;it can be mapped to disk as well.</p>
<p>Swap partitions on Linux allow Linux’s virtual memory system to map meory not only to physical RAM, but also to disk blocks aw well.</p>
<p>processor’s virtual-to-physical memory lookup tables</p>
<p>All of the mermory mappings are done a page at a time. Physical memory assignment, swapping, mapping, etc. are all done to memory pages instead of individual memory addresses.</p>
<p>Sometimes so many programms can be loaded that there is hardly enough physical memory for them. They wind up spending more time just swapping memory on and off of disk than then do actuall processing it.</p>
<p>swap death which lead to your system being unreponsive and unproductive.</p>
<p>The amount of memory that your program currently has in physical memory is called its resident set site(RSS in top).</p>
<p>Linux maps all of your virtual memory into physical memory or swap. If you try to access a piece of virtual memory that hasn’t been mapped yet, it triggers an error known as a segmentation fault, which wiil terminate your program.</p>
<p>beforehand:预先<br>this is all great if you know beforehand how much storage you will need.</p>
<p>If you need more memory, you can just tell Linux where you want the new break point to be, and Linux will map all the memory you need between the current and new break point, and then move the break point to the spot you specify. That memory is now available for your program to use. The way we tell Linux to move the break point is through the brk system call.</p>
<p>A memory manager is a set of routines that takes care of dirty work of getting your program memory for you.</p>
<p>through : 完结de<br>When you’re done with it. you tell deallocate that you are through with i.t</p>
<p>The pool of memory used by memory managers is commonly referred to as the heap.</p>
<p>The way memory managers work is that they keep track of where the system break is, and where the memory than you have allocated is. They mark each block of memory in the heap as being used or unused. When you request memory, then memory manager checks to see if there are any unused blocks of the appropriate size. If not, it calls the brk system call to request more memory. When you free memory it marks the block as unused so that future request can retrieve it. </p>
<p>It is very primitive but is shows the principles quite well.</p>
<p>As usual, I will give you the program first for you to look through. Afterwards will follow an in-depth explanation.</p>
<p>The section of memory being managed is commonly referred to as the heap.</p>
<p>doozy: 非常显眼</p>
<p>simplistic : 过分简单的</p>
<p>Linux can keep pages of memory on disk instead of in memory.</p>
<p>A program that runs in constant time takes the same amount of time no matter how many elements you are managing.</p>
<p>System call takes a long time. They aren’t like functions, becasue hte processor has to switch modes.</p>
<p>The processor has to switch into kernel mode, then Linux maps the memroy, and then swtiches back to user mode for your application to continue running. This is also called a Context Switch. You should avoid calling the kernel unless you really need to.</p>
<p>necessiate: 需要，使成为必需</p>
<p>misnomer : 取名不当。</p>
<p>continually : 不断地, 频繁地</p>
<h1 id="Chapter-10-Counting-like-a-Computer"><a href="#Chapter-10-Counting-like-a-Computer" class="headerlink" title="Chapter 10. Counting like a Computer"></a>Chapter 10. Counting like a Computer</h1><p>Heavy Metal Music</p>
<p>dressy : 衣着考究 Wearing Dressy Clothes</p>
<p>shrl : Shift Right Long.</p>
<p>The 0b notation means that what follows is a binary number.</p>
<p>make a point : 立论</p>
<p>octal:八进制的</p>
<p>mantissa : 尾数, exponent : 指数</p>
<p>quantity : 数量，量</p>
<p>be careful not to put any leading zeroes in front of decimal numbers, or they will be interepreted as octal numbers!</p>
<p>In octal, each digit represented three bits. In hexadecimal, each digit represents four bits.</p>
<p>hexadecimal numbers are prefixed with 0x.</p>
<p>take some getting used to : 要慢慢适应</p>
<p>Hexadecimal and octal numbers take some getting used to, but they are heavily used in computer programming.</p>
<p>controversy : 争论，争吵</p>
<p>account for :解释<br>If you read or write to network sockets, you may have to account for a different byte order in the protocol.</p>
<p>extremely limitted means.</p>
<p>quotient : 商，系数, </p>
<p>little-endian, big-endian</p>
<h1 id="Chapter-11-High-Level-Languages"><a href="#Chapter-11-High-Level-Languages" class="headerlink" title="Chapter 11. High-Level Languages"></a>Chapter 11. High-Level Languages</h1><p>Assembly language is the language used at the machine’s level, but most people find coding in assembly language too cumbersome for everyday use.</p>
<p>marketable</p>
<p>Knowing a wide variety of languages is useful for many reasons, including :</p>
<ul>
<li>Different languages are based on different concept, which will help you to learn different and better programming methods and ideas.</li>
<li>Different languages are good for different types of projects.</li>
<li>Diffreent companies have different standard languages, so knowing more languages makes your skills more marketable.</li>
<li>The more languages you know, the easier it it to pick up new ones.</li>
</ul>
<p>flinch : 畏缩，退缩<br>Languages are simply tools, and learning to use a new tool should not be something a programmer flinches at.</p>
<p>on the spot : 现场的 ,立即</p>
<p>legwork:外勤工作，跑腿<br>do a lot for extra legwork.</p>
<h1 id="Chapter-12-Optimization"><a href="#Chapter-12-Optimization" class="headerlink" title="Chapter 12. Optimization"></a>Chapter 12. Optimization</h1><p>Optimization is the process of making your application run more effectively.</p>
<p>It’s better to not optimize at all than to optimize too soon.</p>
<p>Even experienced programmer have trouble predicting which parts of the program will be the bottlenecks which need optimization, so you will probably end up wasting your time optimizing the wrong parts.</p>
<p>revise : 修改</p>
<p>bouncinng : 跳跃的, bouncing all over the place</p>
<p>chips’ ultra-fase cache memory.</p>
<p>Registers are the fastest memory locations on the computer.</p>
<p>make wise usage of</p>
<p>Functions are greate from the point of view of program management - they make it easy to break up your program into indepenedent, understandable, and resuable parts.</p>
<p>Different addressing modes work at different speeds. The fasted are the immediate and register addressing modes. Direct is the next fastet, indirect is next, and base pointer and indexed indirect are the slowest.</p>
<p>smattering : 肤浅的知识，片段的知识<br>These are just a smattering of examples of the kinds of local optimizations possible.</p>
<p>However, remember that the maintainability and readability of code is much more important except under extreme circumstances.</p>
<p>Global optimization often involves restructuring code to avoid performance problems, rather than trying to find the best way through them.</p>
<p>Usually, applications have a limit to how parallelizable they are. The more parellelizable your application is, the better it can take advantage of multiprocessor and clustered computer configuations.</p>
<p>Two great benefits resultting from statelessness is that most stateless functions are parallelizable and often benefit from memoization.</p>
<h1 id="Chapter-13-Moving-On-from-Here"><a href="#Chapter-13-Moving-On-from-Here" class="headerlink" title="Chapter 13. Moving On from Here"></a>Chapter 13. Moving On from Here</h1><p>leave out : 省去，遗漏</p>
<p>Computer Programming is a vast subject. As a programmer, you will need to be prepared to be constantly learning and pushing your limits.</p>
<p>A language that doesn’t affect the way you think about programming is not worth knowing.</p>
<p>poverty : 贫穷, bandit : 强盗，scarcity : 缺乏，armed 武装</p>
<p>spit : 唾液，吐出</p>
<p>GDB : GNU Debugger</p>
<p>culprit : 犯人， 罪犯</p>
<p>Notice that in GDB, registers are prefixed with dollar signs rather than percent signs.<br>print /d $eax : print in decimal<br>print /$eax : print in hexadecimal</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/31/programming-from-the-ground-study/" data-id="civit9hzf0000u5n2gnpx6bgq" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-chbin-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/chbin-hello-world/" class="article-date">
  <time datetime="2016-10-24T04:09:18.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/chbin-hello-world/">chbin_hello_world</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Install-Git"><a href="#1-Install-Git" class="headerlink" title="1. Install Git"></a>1. Install Git</h1><p><code>brew install git</code></p>
<h1 id="2-Install-Node-js"><a href="#2-Install-Node-js" class="headerlink" title="2. Install Node.js"></a>2. Install Node.js</h1><p>Download the Install Package from the official Site.</p>
<h1 id="3-Install-Hexo"><a href="#3-Install-Hexo" class="headerlink" title="3. Install Hexo"></a>3. Install Hexo</h1><p><code>npm install -g hexo-cli</code></p>
<h1 id="4-Create-first-blog-with-hexo"><a href="#4-Create-first-blog-with-hexo" class="headerlink" title="4. Create first blog with hexo"></a>4. Create first blog with hexo</h1><h2 id="1-Create-GitHub-Pages"><a href="#1-Create-GitHub-Pages" class="headerlink" title="1.Create GitHub Pages"></a>1.Create GitHub Pages</h2><h2 id="2-Setup-SSH-Keys"><a href="#2-Setup-SSH-Keys" class="headerlink" title="2.Setup SSH Keys"></a>2.Setup SSH Keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ssh-keygen -t rsa -C &quot;chenbin1211002@hotmail.com&quot;</div><div class="line">$ssh-agent -s</div><div class="line">#ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure>
<p><code>Copy into github setting&#39;s SSH Keys</code></p>
<p><code>ssh -T git@github.com</code></p>
<h2 id="2-Create-Hexo-Blog"><a href="#2-Create-Hexo-Blog" class="headerlink" title="2.Create Hexo Blog"></a>2.Create Hexo Blog</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$cd /Users/chbin/Projects/hexo_git_markdown/</div><div class="line">$hexo init cncomkyle</div><div class="line">$npm i</div><div class="line">$git init</div><div class="line">$npm i -S hexo-deployer-git</div></pre></td></tr></table></figure>
<h2 id="3-Change-config-yml"><a href="#3-Change-config-yml" class="headerlink" title="3. Change _config.yml"></a>3. Change _config.yml</h2><p><code>Emacs _config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy: </div><div class="line">  type: git</div><div class="line">  repo: git@github.com:cncomkyle/cncomkyle.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>Save &amp; Quit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$hexo generate -d</div><div class="line">$hexo deploy</div></pre></td></tr></table></figure>
<h2 id="3-Deploy-new-post"><a href="#3-Deploy-new-post" class="headerlink" title="3.Deploy new post"></a>3.Deploy new post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$hexo new chbin_test</div><div class="line">$emacs vi source/_posts/chbin_test.md</div><div class="line">$hexo generate -d</div></pre></td></tr></table></figure>
<h1 id="5-Install-MacDown"><a href="#5-Install-MacDown" class="headerlink" title="5. Install MacDown"></a>5. Install MacDown</h1><h1 id="6-Refer-Link-List"><a href="#6-Refer-Link-List" class="headerlink" title="6. Refer Link List"></a>6. Refer Link List</h1><ol>
<li><a href="https://zirho.github.io/2016/06/04/hexo/" target="_blank" rel="external">How to setup a blog on github with Hexo</a></li>
<li><a href="How to setup a blog on github with Hexo">GitHub Pages</a></li>
<li><a href="http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html" target="_blank" rel="external">史上最详细“截图”搭建Hexo博客并部署到Github</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/24/chbin-hello-world/" data-id="civit9hzm0001u5n2iegu5oul" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/hello-world/" class="article-date">
  <time datetime="2016-10-24T03:48:32.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/24/hello-world/" data-id="civit9hzq0002u5n2si77d05f" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/31/programming-from-the-ground-study/">programming_from_the_ground_study</a>
          </li>
        
          <li>
            <a href="/2016/10/24/chbin-hello-world/">chbin_hello_world</a>
          </li>
        
          <li>
            <a href="/2016/10/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>